# 1단계. 문제 이해 및 설계 범위 확정

### 요구사항

- 빠른 응답 속도
- 연관성
- 정렬
- 규모 확장성
- 고가용성

# 2단계. 개략적 설계안 제시 및 동의 구하기

## 데이터 수집 서비스

사용자의 질의를 실시간으로 수집

## 질의 서비스

주어진 질의에 인기 검색어를 정렬하여 제공

# 3단계. 상세 설계

## 트라이 자료구조

- p: 접두어 길이
- n: 트라이 안에 있는 노드 개수
- c: 주어진 노드의 자식 노드 개수

### 시간 복잡도

- 해당 접두어 노드 찾기: O(p)
- 유효 노드 찾기: O(c)
- 인기 있는 검색어 k개 찾기: O(clogc)

### 시간 복잡도 줄이기

- 접두어 최대 길이 제한
- 노드에 인기 검색어 캐시

## 데이터 수집 서비스

- 질의마다 트라이를 갱신하면 서비스는 심각하게 느려진다.
- 트라이가 만들어지고 나면 자주 갱신할 필요가 없다.

### 데이터 분석 서비스 로그

질의에 관한 원본 데이터 보관

추가만 될 뿐 수정은 이루어지지 않는다.

### 로그 취합 서버

데이터를 취합하여 시스템이 쉽게 소비할 수 있도록 함

### 취합된 데이터

질의, 시간, 횟수 등을 기록

### 작업 서버

비동기적 작업을 실행하는 서버 집합

트라이 자료구조를 만들고 트라이 데이터베이스에 저장하는 역할 담당

### 트라이 캐시

분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높임

매주 트라이 데이터베이스의 스냅샷을 갱신

### 트라이 데이터베이스

지속성 저장소

- 문서 저장소: 새 트라이를 매주 만들 것이므로, 주기적으로 트라이를 직렬화하여 데이터베이스에 저장 ex) MongoDB
- 키-값 저장소: 아래 로직을 적용하면 해시 테이블 형태로 변환 가능
    - 모든 접두어를 해시 테이블 키로 변환
    - 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환

## 질의 서비스

### 최적화 방안

- ajax 요청
- 브라우저 캐싱
- 데이터 샘플링

## 규모 확장이 가능한 저장소

검색어 대응 샤드 관리자를 통해 어떤 검색어가 어느 저장소에 저장되는지에 대한 정보를 관리

글자마다 검색 양이 다르므로 이를 고려하여 분배

## 트라이 연산

# 4단계. 마무리

### 실시간 검색어 자동완성을 위한 문제

- 샤딩을 통하여 작업 대상 데이터 양을 줄임
- 순위 모델을 바꾸어 최근 검색어에 높은 가중치
- 데이터가 스트림 형태로 올 수 있음
