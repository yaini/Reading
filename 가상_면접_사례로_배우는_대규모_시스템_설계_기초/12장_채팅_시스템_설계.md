# 1단계. 문제 이해 및 설계 범위 확정

# 2단계. 새략적 설계안 제시 및 동의 구하기

클라이언트는 서로 직접 통신하지 않고 채팅 서비스와 통신

### 제공해야 할 서비스

- 클라이언트들로부터 메세지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메세지 보관

## 채팅 서비스 프로토콜

### 폴링

클라이언트가 주기적으로 서버에게 메세지 유무를 물어보는 방법

메세지가 없는 경우엔 자원이 불필요하게 낭비됨

### 롱 폴링

클라이언트는 새 메세지가 반환되거나 타임아웃 될 때까지 연결을 유지

**단점**

- 메세지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다.
    
    http 서버들은 보통 무상태 서버다. 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 메세지를 받은 서버는 해당 메세지를 수신할 클라이언트와 롱 폴링 연결을 가지고 있지 않은 서버일 수 있음
    
- 서버 입장에선 클라이언트가 연결을 해제했는지 아닌지 알 방법이 없다.
- 여전히 비효율적, 주기적으로 다시 접속한다

### 웹소켓

서버가 클라이언트에게 비동기 메세지를 보낼 때 가장 널리 사용하는 기술

클라이언트가 연결을 시작하고, 맺어진 연결은 항구적이고 양방향

처음엔 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드

80이나 443처럼 기본 포트번호를 그대로 쓰기 때문에 방화벽에서도 잘 동작

웹 소켓을 이용하면 주고 받을 때 동일한 프로토콜을 사용할 수 있으므로 설계와 구현이 단순하고 직관적, HTTP를 굳이 사용할 필요 없음

## 개략적 설계안

- 무상태 서비스
- 상태 유지 서비스
- 제3자 서비스 연동
- 규모 확장성

### 서비스 탐색 서비스

클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할

채팅 서비스를 고려하여 특정 서버에 부하가 몰리지 않도록 함

### 저장소

채팅 시스템이 다루는 데이터

- 사용자 프로파일링, 설정, 친구 목록
    - 안정성을 보장하는 관계형 데이터 베이스
    - 다중화와 샤딩은 이런 데이터의 가용성과 규모 확장성을 보증
- 채팅 이력
    - 수평적 규모 확장이 쉽다
    - 데이터 접근 지연시간이 낮다
    - 관계형 데이터 베이스는 롱 테일 부분을 잘 처리하지 못함, 인덱스가 커지면 무작위 접근을 처리하는 비용이 늘어남

## 데이터 모델

### 메세지 ID

- message_id의 값은 고유해야 함
- ID 값은 정렬 가능해야 하며 시간 순서와 일치

RDMS는 auto_increment가 있지만 NoSQL은 보통 해당 기능을 제공하지 않음

**지역적 순서 번호 생성기를 이용**

ID의 유일성은 같은 그룹 안에서만 보증하면 충분

전역적 ID 생성기에 비해 구현하기 쉬움

# 3단계. 상세 설계

## 서비스 탐색

클라이언트에게 가장 적합한 채팅 서버를 추천

기준으로는 클라이언트의 위치, 서버의 용량 등이 있음

ex) 아파치 주키퍼

## 메세지 흐름

### 1:1 채팅 메세지 처리 흐름

1. 사용자가 채팅 서버로 메세지 전송
2. 채팅 서버는 ID 생성기를 사용해 메세지의 ID를 결정한 후 동기화 큐로 전송
3. 메세지가 키-값 저장소에 보관
4. 메세지를 받는 사용자가 접속 중인 경우 채팅 서버로 전송, 접속 중이 아니면 푸시 알림 서버로 전송
5. 웹소켓 연결을 통해 메세지 전달

### 여러 단말 사이의 메세지 동기화

각 단말은 cur_max_message_id라는 변수를 유지

해당 단말에서 관측된 가장 최신 메세지의 ID를 추적하는 용도

- 수신자 ID가 현재 로그인한 사용자 ID와 같다
- 키-값 저장소에 보관된 메세지로서, 그 ID가 cur_max_message_id보다 크다.

### 소규모 그룹 채팅에서의 메세지 흐름

발신자가 보낸 메세지가 수신자의 메세지 동기화 큐에 복사됨

이 설계는 소규모 그룹 채팅에 적합하다

- 새로운 메세지가 왔는지 확인하려면 자기 큐만 보면 되므로 메세지 동기화 플로우가 비슷하다.
- 그룹이 크지 않으면 메세지를 수신자별로 복사해서 큐에 넣는 작업 비용이 문제가 되지 않는다.

## 접속상태 표시

### 사용자 로그인

클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관

### 로그아웃

키-값 저장소에 보관된 사용자의 상태가 online에서 offline으로 바뀜

### 접속 장애

인터넷 연결이 끊어지면 웹 소켓 같은 지속성 연결도 끊어진다.

이런 장애에 대응하기 위한 간단한 방법은 사용자를 오프라인 상태로 표시하고 연결이 복구되면 온라인 상태로 변경하는 것이다.

→ 하지만 이런 일은 흔하기 때문에 계속 접속 상태를 변경하는 건 바람직하지 않다.

따라서 온라인 상태의 클라이언트로 하여금 주기적으로 박동 이벤트를 서버로 보내도록하고 x초 이내로 이벤트가 계속 된다면 온라인으로 유지

### 상태 정보의 전송

상태 정보 서버는 발행-구독 모델을 사용

각각의 친구관계 마다 채널을 하나씩 둠

그룹 크기가 커지면 수동으로 갱신하는 것이 좋음

# 4단계. 마무리

더 고려해볼 사항

- 사진이나 비디오 등의 미디어 지원
- 종단 간 암호화
- 캐시
- 로딩 속도 개선
- 오류 처리
    - 채팅 서버 오류
    - 메세지 재전송
