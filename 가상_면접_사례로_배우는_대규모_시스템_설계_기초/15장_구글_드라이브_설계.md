# 1단계. 문제 이해 및 설계 범위 확정

### 기능적 요구사항

- 파일 추가
- 파일 다운로드
- 여러 단말에 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시

### 비기능적 요구사항

- 안정성
- 빠른 동기화 속도
- 네트워크 대역폭
- 규모 확장성
- 높은 가용성

# 2단계. 개략적 설계안 제시 및 동의 구하기

## API

### 파일 업로드 API

- 단순 업로드: 파일 크기가 작을 때
- 이어 올리기: 파일 사이즈가 크고 네트워크 문제로 업로드가 중단될 가능성이 높을 때
    - 이어 올리기 URL을 받기 위한 최초 요청 전송
    - 데이터를 업로드하고 업로드 상태 모니터링
    - 업로드에 장애가 발생하면 장애 발생시점부터 업로드를 재시작

### 다운로드 API

### 파일 갱신 히스토리 제공 API

## 한 대 서버의 제약 극복

업로드 파일이 많아지다 보면 데이터를 샤딩해야 한다.

## 동기화 충돌

참조 문헌

## 개략적 설계안

- **블록 저장소 서버**
    
    파일 블록을 클라우드 저장소에 업로드하는 서버
    
    클라우드 환경에서 데이터 파일을 저장하는 기술
    
    파일을 여러 개의 블록으로 나눠 저장하며, 각 블록에는 고유한 해시값이 할당된다. 이 해시값은 메타데이터 데이터베이스에 저장됨
    
    각 블록은 독립적인 객체로 취급되며 클라우드 저장소 시스템에 보관
    
- **클라우드 저장소**
    
    블록 단위의 파일들이 저장되는 곳
    
- **아카이빙 저장소**
    
    오랫동안 사용되지 않은 비활성 데이터 저장
    

# 3단계. 상세 설계

## 블록 저장소 서버

클라이언트가 보낸 파일을 블록 단위로 나누고, 압축 알고리즘을 적용하고, 암호화 수행

### 큰 파일 업데이트 최적화

- 델타 동기화: 수정이 일어난 블록만 동기화
- 압축

## 높은 일관성 요구사항

- 캐시에 보관된 사본과 데이터베이스에 있는 원본이 일치한다.
- 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화 한다.

NoSQL은 ACID를 지원하지 않으므로, 높은 일관성을 위해선 동기화 로직을 추가해야 한다.

## 업로드 절차

- 파일 메타데이터 추가
- 파일을 클라우드 저장소에 업로드

## 다운로드 절차

- 클라이언트가 접속 중일 경우 알림 서비스 이용
- 접속 중이 아닐 경우 캐시에 보관

## 알림 서비스

- 롱 폴링
    - 채팅 서비스와 달리 양방향 통신이 필요하지 않음
    - 단시간에 많은 양의 데이터를 보내지 않음
- 웹 소켓

## 저장소 공간 절약

모든 버전을 자주 백업하면 저장용량이 너무 빨리 소진될 수 있음

- 중복 제거: 중복된 파일 블록을 계정 차원에서 제거, 해시값을 비교하여 판단
- 지능적 백업 전략
    - 한도 설정
    - 중요한 버전만 보관
- 자주 쓰이지 않는 데이터는 아카이빙 저장소로

# 4단계. 마무리

### 블록 저장소를 거치지 않을 경우 문제점

- 분할, 압축, 암호화 로직을 클라이언트에 두어야 하므로 플랫폼별로 따로 구현
- 클라이언트가 해킹당할 가능성이 있으므로 암호화 로직을 클라이언트에 두는 것은 적절하지 않다.
