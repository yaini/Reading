# 1.1 초난감 DAO

- **DAO**: DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
- **자바빈**: 디폴트 생성자, 프로퍼티를 가지는 오브젝트

# 1.2 DAO의 분리

- **관심사 분리**:  관심이 같은 것끼리는 하나의 객체 안으로 모이게 하고,

    관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리하는 것

## 1.2.2 커넥션 만들기의 추출

### Dao의 관심사항

- DB와 연결을 위한 커넥션을 어떻게 가져올까
- DB에 보낼 SQL문장을 만들고 실행
- 공유 리소스를 시스템에 돌려줌

- **리팩토링**: 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업

## 1.2.3 DB 커넥션 만들기의 독립

### 템플릿 메소드 패턴

슈퍼클래스에서 기본적인 로직의 흐름과 기능의 일부를 오버라이딩이 가능한 메소드로 만들고

서브클래스에서 이런 메소드를 필요에 맞게 구현하여 사용하는 디자인 패턴

변하지 않는 기능은 슈퍼클래스에, 자주 변경되고 확장되는 기능은 서브클래스에서 구현

제어의 역전을 활용한 디자인 패턴

- **hook 메소드**: 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만든 메소드

### 팩토리 메소드 패턴

템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 디자인 패턴

슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 호출함

서브클래스에서 구체적인 오브젝트 **생성 방법**을 결정하게 함

팩토리 메소드와 팩토리 메소드 패턴의 팩토리 메소드는 다른 의미이므로 주의

# 1.3 DAO의 확장

## 1.3.4 원칙과 패턴

### 개방 폐쇄 원칙

클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다.

### 객체지향 설계 원칙(SOLID)

- **SRP**: 단일 책임 원칙
- **OCP**: 개방 폐쇄 원칙
- **LSP**: 리스코프 치환 원칙
- **ISP**: 인터페이스 분리 원칙
- **DIP**: 의존 관계 역전 원칙

### 높은 응집도와 낮은 결합도

- **높은 응집도**: 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다
- **낮은 결합도**: 책임과 관심사가 다른 오브젝트 또는 모듈과 느슨하게 연결되어 있다.

### 전략 패턴

자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴

# 1.4 제어의 역전(IoC)

오브젝트가 자신이 사용할 오브젝트를 스스로 선택/생성하지 않는다.

모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.

## 1.4.1 오브젝트 팩토리

### 팩토리

객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 클래스

오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리

어플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의

## 1.4.3 제어권 이전을 통한 제어관계 역전

ex) 서블릿, 템플릿 메소드 패턴, 프레임워크

- **프레임 워크 vs 라이브러리**

    라이브러리를 사용하면 어플리케이션이 직접 흐름을 제어하지만.

    프레임 워크는 거꾸로 어플리케이션의 코드가 프레임워크에 의해 사용된다.

# 1.5 스프링의 IoC

## 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

- **빈**: 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트, 제어의 역전 적용
- **빈팩토리**: 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
- **어플리케이션 컨텍스트**: IoC 방식을 따라 빈팩토리를 확장

### DaoFactory를 사용하는 어플리케이션 컨텍스트

@Configuration: 빈팩토리를 위한 오브젝트 설정을 담당하는 클래스

@Bean: 오브젝트를 만들어주는 메소드

## 1.5.2 어플리케이션 컨텍스트의 동작방식

### 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.

오브젝트 팩토리가 많아져도 클라이언트가 이를 모두 알아야 할 필요가 없다.

어플리케이션 컨텍스트에서 일관적인 방식으로 가져올 수 있음

### 어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.

어플리케이션 컨텍스트는 오브젝트가 만들어지는 방식, 시점, 후처리 등 다양한 기능 제공

빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공

### 어플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

타입만으로 빈을 검색하거나 특별한 어노테이션 설정이 되어있는 빈도 찾을 수 있다.

## 1.5.3 스프링 IoC의 용어 정리

### 빈/빈 오브젝트

스프링이 IoC방식으로 관리하는 오브젝트

스프링을 사용하는 어플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아님

스프링이 직접 그 생성과 제어를 담당하는 오브젝트만 빈이라고 부른다.

### 빈 팩토리

스프링의 IoC를 담당하는 핵심 컨테이너

빈을 등록/생성/조회/반환 등 관리하는 기능 담당

보통 빈팩토리를 바로 사용하지 않고 이를 확장한 어플리케이션 컨텍스트 사용

### 어플리케이션 컨텍스트

빈 팩토리를 확장한 IoC 컨테이너

기본적인 기능은 빈팩토리와 동일, 스프링이 제공하는 부가 서비스를 추가로 제공

어플리케이션 컨텍스트는 빈팩토리를 상속

### 설정정보/설정 메타정보

어플리케이션 컨텍스트 또는 빈팩토리가 IoC를 적용하기 위해 사용하는 메타정보

### 컨테이너/IoC컨테이너

IoC방식으로 빈을 관리

어플리케이션 컨텍스트와 빈팩토리를 IoC컨테이너 라고 함

# 1.6 싱글톤 레지스트리와 오브젝트 스코프

- **동일성`=`과 동등성`equals()`**

    두 오브젝트가 동일하다면 사실 하나의 오브젝트만 존재

    두 오브젝트가 동등하다면 값이 같은 다른 오브젝트

어플리케이션 컨텍스트를 통해 오브젝트를 생성하면 동일한 오브젝트를 반환함

## 1.6.1 싱글톤 레지스트리로서의 어플리케이션 컨텍스트

스프링은 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

디자인 패턴의 싱글톤과 비슷한 개념이지만 구현 방법은 다르다.

 

### 서버 어플리케이션과 싱글톤

- **왜 스프링은 싱글톤으로 빈을 만들까?**

    스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문

    매번 클라이언트에서 요청이 올 때마다 새로운 오브젝트를 만들면 서버가 감당하기 힘들다.

### 싱글톤 패턴의 한계

private 생성자를 갖고 있기 때문에 상속할 수 없다.

싱글톤은 테스트하기 어렵다

서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.

싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.

- **싱글톤 구현 방법**

    생성자를 private로 구현

    생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 static 필드 정의

    스태틱 팩토리 메소드인 getInstance를 만들고 이 메소드가 최초로 호출되는 시점에 한번만 오브젝트가 생성되도록 함

    생성된 오브젝트는 스태틱 필드에 저장

    getInstance메소드를 통해 만들어져있는 오브젝트를 넘겨줌

### 싱글톤 레지스트리

스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 이걸 **싱글톤 레지스트**리라고 함

스태틱 메소드와 private 생성자 없이 싱글톤으로 관리할 수 있음

## 1.6.2 싱글톤과 싱글톤 오브젝트의 상태

싱글톤은 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우 무상태 방식이어야 함

싱글톤은 기본적으로 인스턴스필드의 값을 변경하고 유지하는 상태유지 방식으로 만들어지지 않음

스프링의 싱글톤 빈 클래스에서 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나 파라미터 사용

스프링의 빈/읽기전용 값은 인스턴스 변수로 사용해도 됨

## 1.6.3 스프링 빈의 스코프

스프링 빈의 기본 스코프는 싱글톤

스프링 컨테이너가 존재하는 동안 계속 유지

# 1.7 의존관계 주입(DI)

## 1.7.1 제어의 역전(IoC)과 의존관계 주입

DI는 오브젝트 레퍼런스를 외부로부터 제공받고 이를 통해 다른 오브젝트와 의존관계가 만들어지는 것이 핵심

## 1.7.2 런타임 의존관계 설정

### 의존 오브젝트

런타임 시에 의존관계를 맺는 대상

인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 런타임 시에 사용할 오브젝트가 어떤 클래스인지 알 수 없다.

### 의존관계 주입

구체적인 의존 오브젝트와 클라이언트를 런타임 시에 연결해주는 작업

- 런타임 시점에 의존관계가 드러나지 않음, 인터페이스에 의존
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정
- 의존관계는 오브젝트의 레퍼런스를 외부에서 제공해줌

- **DI 컨테이너**: 오브젝트를 만들고 이 생성자의 파라미터로 의존관꼐를 맺어줄 오브젝트의 레퍼런스를 전달

## 1.7.3 의존관계 검색과 주입

### 의존관계 검색 *Dependency Lookup*

의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용

자신이 필요로 하는 의존 오브젝트를 능동적으로 찾음

getBean 메소드가 바로 의존관계 검색에 사용

의존관계 주입 방식과 다른 점은 자신이 스프링 빈일 필요가 없다(컨테이너가 오브젝트를 주입해주려면 생성/초기화 권한 필요)
