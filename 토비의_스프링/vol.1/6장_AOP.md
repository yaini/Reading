# 6.1 트랜잭션 코드의 분리

## 6.1.2 DI를 이용한 클래스의 분리

- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 DI 적용 이유

    구현 클래스를 바꿔가면서 사용하기 위해

    ex) 테스트, 운영 중에 따라 클래스 다르게 적용

Service 인터페이스를 비즈니스 로직을 담은 Impl 클래스와 트랜잭션 처리를 담은 Tx 클래스로 구분하여 구현

의존관계: Client → ServiceTx → ServiceImpl

### 트랜잭션 경계설정 코드 분리의 장점

- 비즈니스와 트랜잭션 관심사 구분
- 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음

# 6.2 고립된 단위 테스트

### 작은 단위 테스트가 좋은 이유

- 실패했을 때 원인을 찾기 쉬움
- 의도나 내용이 분명해지고, 만들기 쉬워짐
- 작은 단위의 테스트로 검증한 부분은 제외하고 접근할 수 있음
- 환경이 달라졌을때 의존된 오브젝트에서 결과 값이 다를 수 있음
- 테스트가 커지면 속도가 느려짐

## 6.2.3 단위테스트와 통합테스트

### 단위테스트

테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것

### 통합테스트

외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

*ex) 스프링의 테스트 컨텍스트 프레임워크를 통해 DI된 오브젝트 테스트, DAO 테스트*

## 6.2.4 목 프레임워크

### Mockito 프레임 워크

1. 인터페이스를 이용해 목 오브젝트를 만듬
2. 목 오브젝트가 리턴할 값이나 예외를 지정
3. 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만듬
4. 오브젝트 사용 후, 목 오브젝트의 특정 메소드가 어떤 값으로 몇번 호출되었는지 검증

# 6.3 다이내믹 프록시와 팩토리 빈

## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

### 프록시

마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아줌

타깃과 같은 인터페이스를 구현하여, 프록시가 타깃을 제어할 수 있는 위치에 있음

- 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
- 부가적은 기능을 부여해주기 위해

### 타깃, 실체

프록시를 통해 최종적으로 요청을 위임받아 처리하는 오브젝트

```python
클라이언트 ---> 프록시 ---> 타깃
```

### 데코레이터 패턴

타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴

실제 내용물은 동일하지만 부가적인 효과 제공

- **다이나믹하게 기능을 부여한다?**

    컴파일 시점, 즉 코드 상에서 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않음

### 프록시 패턴

프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적

타깃의 기능을 확장하거나 추가하지 않음

타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우엔 생성하지 않는 편이 좋음

하지만 레퍼런스가 미리 필요할 수 있으므로, 이때 프록시 패턴 적용

클라이언트에게 실제 타깃 오브젝트 대신 프록시를 넘겨줌

프록시의 메소드를 통해 타깃 사용시, 타깃을 생성하고 요청을 위임해줌

ex) 원격 오브젝트 이용(RMI, EJB 등), Collections의 unmodifiableCollection()

## 6.3.2 다이나믹 프록시

### 프록시를 만들기 번거로운 이유

- **타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.**

    부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어야 함

    인터페이스의 메소드가 많아지면 유지보수가 힘듬

- **부가기능 코드가 중복될 가능성이 많다.**

    메소드가 많아지고 부가기능 적용 비율이 높아지면 유사한 코드가 중복됨

### 리플렉션

자바의 코드 자체를 추상화하여 접근하도록 만든 것

다이나믹 프록시는 리플렉션 기능을 이용하여 프록시를 만들어줌

private으로 선언된 접근 규약을 위반할 수 있음

- **invoke 메소드**

    메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌

## 6.3.4 다이나믹 프록시를 위한 팩토리 빈

다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로 등록할 방법이 없음

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름으로 빈 오브젝트 생성

다이나믹 프록시 오브젝트는 클래스 자체도 다이나믹하게 정의해서 사용

다이나믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 생성

### 팩토리 빈

스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 방법을 제공하는데, 그 중 하나

스프링의 FactoryBean 인터페이스를 구현해서 만듬

class를 팩토리 빈으로 설정해도 getObjectType 메소드가 돌려주는 타입으로 결정됨 

### 테스트

@DirtiesContext 를 이용해 컨텍스트 무효화

&오브젝트로 팩토리 빈 자체를 가져옴

수정자 메소드를 이용해 Target을 테스트용으로 변경

## 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

### 프록시 팩토리 빈의 장점

코드의 수정 없이도 다양한 클래스에 적용

데코레이터 패턴에서 문제점이 였던 인터페이스 구현을 하지 않아도 됨

다이나믹 프록시 생성 코드 제거

### 프록시 팩토리 빈의 한계

한번에 여러 개 메소드에 공통 기능 제공은 가능하지만 한번에 여러 개 클래스는 불가능

여러 개 프록시 제공 시 중복 코드

프록시 팩토리 빈 내의 오브젝트가 빈 개수만큼 만들어짐

# 6.4 스프링의 프록시 팩토리 빈

## 6.4.1 ProxyFactoryBean

스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공

생성된 프록시는 스프링의 빈으로 등록되어야 함

순수하게 프록시를 생성하는 작업만 담당하고 제공해주는 기능은 별도의 빈에 둘 수 있음
