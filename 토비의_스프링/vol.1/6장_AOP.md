# 6.1 트랜잭션 코드의 분리

## 6.1.2 DI를 이용한 클래스의 분리

- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 DI 적용 이유

    구현 클래스를 바꿔가면서 사용하기 위해

    ex) 테스트, 운영 중에 따라 클래스 다르게 적용

Service 인터페이스를 비즈니스 로직을 담은 Impl 클래스와 트랜잭션 처리를 담은 Tx 클래스로 구분하여 구현

의존관계: Client → ServiceTx → ServiceImpl

### 트랜잭션 경계설정 코드 분리의 장점

- 비즈니스와 트랜잭션 관심사 구분
- 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음

# 6.2 고립된 단위 테스트

### 작은 단위 테스트가 좋은 이유

- 실패했을 때 원인을 찾기 쉬움
- 의도나 내용이 분명해지고, 만들기 쉬워짐
- 작은 단위의 테스트로 검증한 부분은 제외하고 접근할 수 있음
- 환경이 달라졌을때 의존된 오브젝트에서 결과 값이 다를 수 있음
- 테스트가 커지면 속도가 느려짐

## 6.2.3 단위테스트와 통합테스트

### 단위테스트

테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것

### 통합테스트

외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

*ex) 스프링의 테스트 컨텍스트 프레임워크를 통해 DI된 오브젝트 테스트, DAO 테스트*

## 6.2.4 목 프레임워크

### Mockito 프레임 워크

1. 인터페이스를 이용해 목 오브젝트를 만듬
2. 목 오브젝트가 리턴할 값이나 예외를 지정
3. 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만듬
4. 오브젝트 사용 후, 목 오브젝트의 특정 메소드가 어떤 값으로 몇번 호출되었는지 검증

# 6.3 다이내믹 프록시와 팩토리 빈

## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

### 프록시

마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아줌

타깃과 같은 인터페이스를 구현하여, 프록시가 타깃을 제어할 수 있는 위치에 있음

- 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
- 부가적은 기능을 부여해주기 위해

### 타깃, 실체

프록시를 통해 최종적으로 요청을 위임받아 처리하는 오브젝트

```python
클라이언트 ---> 프록시 ---> 타깃
```

### 데코레이터 패턴

타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴

실제 내용물은 동일하지만 부가적인 효과 제공

- **다이나믹하게 기능을 부여한다?**

    컴파일 시점, 즉 코드 상에서 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않음

### 프록시 패턴

프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적

타깃의 기능을 확장하거나 추가하지 않음

타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우엔 생성하지 않는 편이 좋음

하지만 레퍼런스가 미리 필요할 수 있으므로, 이때 프록시 패턴 적용

클라이언트에게 실제 타깃 오브젝트 대신 프록시를 넘겨줌

프록시의 메소드를 통해 타깃 사용시, 타깃을 생성하고 요청을 위임해줌

ex) 원격 오브젝트 이용(RMI, EJB 등), Collections의 unmodifiableCollection()

## 6.3.2 다이나믹 프록시

### 프록시를 만들기 번거로운 이유

- **타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.**

    부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어야 함

    인터페이스의 메소드가 많아지면 유지보수가 힘듬

- **부가기능 코드가 중복될 가능성이 많다.**

    메소드가 많아지고 부가기능 적용 비율이 높아지면 유사한 코드가 중복됨

### 리플렉션

자바의 코드 자체를 추상화하여 접근하도록 만든 것

다이나믹 프록시는 리플렉션 기능을 이용하여 프록시를 만들어줌

private으로 선언된 접근 규약을 위반할 수 있음

- **invoke 메소드**

    메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려줌

## 6.3.4 다이나믹 프록시를 위한 팩토리 빈

다이나믹 프록시 오브젝트는 일반적인 스프링의 빈으로 등록할 방법이 없음

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름으로 빈 오브젝트 생성

다이나믹 프록시 오브젝트는 클래스 자체도 다이나믹하게 정의해서 사용

다이나믹 프록시는 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서만 생성

### 팩토리 빈

스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈

스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 방법을 제공하는데, 그 중 하나

스프링의 FactoryBean 인터페이스를 구현해서 만듬

class를 팩토리 빈으로 설정해도 getObjectType 메소드가 돌려주는 타입으로 결정됨 

### 테스트

@DirtiesContext 를 이용해 컨텍스트 무효화

&오브젝트로 팩토리 빈 자체를 가져옴

수정자 메소드를 이용해 Target을 테스트용으로 변경

## 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

### 프록시 팩토리 빈의 장점

코드의 수정 없이도 다양한 클래스에 적용

데코레이터 패턴에서 문제점이 였던 인터페이스 구현을 하지 않아도 됨

다이나믹 프록시 생성 코드 제거

### 프록시 팩토리 빈의 한계

한번에 여러 개 메소드에 공통 기능 제공은 가능하지만 한번에 여러 개 클래스는 불가능

여러 개 프록시 제공 시 중복 코드

프록시 팩토리 빈 내의 오브젝트가 빈 개수만큼 만들어짐

# 6.4 스프링의 프록시 팩토리 빈

## 6.4.1 ProxyFactoryBean

스프링은 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공

생성된 프록시는 스프링의 빈으로 등록되어야 함

순수하게 프록시를 생성하는 작업만 담당하고 제공해주는 기능은 MethodInterceptor 인터페이스를 구현한 별도의 빈에 둘 수 있음

인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄

인터페이스 일부만 적용하고 싶다면 직접 제공

### 어드바이스: 타깃이 필요 없는 순수한 부가기능

스프링에서 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트

타깃 오브젝트가 담긴 MethodInvocation 오브젝트 전달

타깃 정보를 갖고 있지 않기 때문에 싱글톤 빈으로 등록

여러 개의 MethodInterceptor를 추가해 다양한 부가기능 제공

### 포인트컷: 부가기능 적용 대상 메소드 선정 방법

Pointcut 인터페이스를 구현해서 생성

트랜잭션 적용 메소드 패턴은 프록시마다 다를 수 있기 때문에 특정 패턴을 넣으면 문제가 됨

메소드와 클래스 모두 적용 가능

```python
어드 바이저 = 포인트컷(메소드 선정 알고리즘) + 어드바이스(부가기능)
```

# 6.5 스프링 AOP

## 6.5.1 자동 프록시 생성

### 빈 후처리기

BeanPostProcessor 인터페이스를 구현해서 만듬

스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.

빈 후처리기가 빈으로 등록되어 있으면, 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업 요청

## 6.5.2 DefaultAdvisorAutoProxyCreator의 적용

### DefaultAdvisorAutoProxyCreator

등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.

생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용하면서 프록시 적용대상 선정

적용 대상이라면, 프록시를 만들어 원래 빈 오브젝트와 바꿈(프록시 오브젝트를 DI)

프록시 뒤에 빈 오브젝트가 연결되면서 프록시를 통해서만 접근 가능

### 테스트를 통해 확인해야 하는 것

트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가

아무 빈에나 트랜잭션 부가기능이 적용된 것은 아닌지

## 6.5.3 포인트컷 표현식을 이용한 포인트컷

### 포인트컷 표현식

표현식 언어를 사용해서 포인트컷 작성

AspectJExpressionPoincut 클래스 사용

표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴임

ex) excution(), bean(), @annotation

```python
execution([접근제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴|"..", ...) [throws 예외 패턴])
```

## 6.5.4 AOP란 무엇인가?

### 부가기능의 모듈화

부가기능은 핵심기능과 같은 방식으로는 모듈화하기가 매우 힘들다. 

부가기능이기 때문에 독립적인 방식으로 존재해서는 적용되기어렵기 때문

### AOP: 애스펙트 지향 프로그래밍

어플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트로 만들어 설계하고 개발하는 방법

- **Aspect**

    어플리케이션의 핵심기능을 담고  있지는 않지만, 핵심기능에 부가되어 의미를 갖는 특별한 모듈

## 6.5.5 AOP 적용 기술

### 프록시를 이용한 AOP

스프링의 AOP는 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만듬

### 바이트코드 생성과 조작을 통한 AOP

AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술

타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 방법ㅇ르 사용

컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트 코드를 조작하는 방법

- 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP 적용
- 프록시 방식보다 강력하고 유연한 AOP 가능

## 6.5.6 AOP의 용어

### 타깃

부가기능을 부여할 대상

핵심기능을 담은 클래스 혹은 다른 부가기능을 제공하는 프록시 오브젝트

### 어드바이스

타깃에게 제공할 부가기능을 담은 모듈

오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다.

### 조인 포인트

어드바이스가 적용될 수 있는 위치

스프링의 프록시 AOP에서 조인포인트는 메소드의 실행 단계

### 포인트컷

어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈

### 프록시

클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트

DI를 통해 타깃 대신 클라이언트에게 주입됨

### 어드바이저

포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트

스프링 AOP에서만 사용되는 특별한 용어

### 애스펙트

AOP의 기본 모듈

한 개 또는 그 이상의 포인트컷과 어드바이스의 조합

싱글톤 형태의 오브젝트

## 6.5.7 AOP 네임 스페이스

스프링에선 aop 스키마 제공

스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

- 자동 프록시 생성기
- 어드바이스
- 포인트컷
- 어드바이저

# 6.6 트랜잭션 속성

## 6.6.1 트랜잭션 정의

더 이상 쪼갤 수 없는 최소 단위의 작업

DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스에서 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성


