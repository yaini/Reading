# 6.1 트랜잭션 코드의 분리

## 6.1.2 DI를 이용한 클래스의 분리

- 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 DI 적용 이유

    구현 클래스를 바꿔가면서 사용하기 위해

    ex) 테스트, 운영 중에 따라 클래스 다르게 적용

Service 인터페이스를 비즈니스 로직을 담은 Impl 클래스와 트랜잭션 처리를 담은 Tx 클래스로 구분하여 구현

의존관계: Client → ServiceTx → ServiceImpl

### 트랜잭션 경계설정 코드 분리의 장점

- 비즈니스와 트랜잭션 관심사 구분
- 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있음

# 6.2 고립된 단위 테스트

### 작은 단위 테스트가 좋은 이유

- 실패했을 때 원인을 찾기 쉬움
- 의도나 내용이 분명해지고, 만들기 쉬워짐
- 작은 단위의 테스트로 검증한 부분은 제외하고 접근할 수 있음
- 환경이 달라졌을때 의존된 오브젝트에서 결과 값이 다를 수 있음
- 테스트가 커지면 속도가 느려짐

## 6.2.3 단위테스트와 통합테스트

### 단위테스트

테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트하는 것

### 통합테스트

외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트

*ex) 스프링의 테스트 컨텍스트 프레임워크를 통해 DI된 오브젝트 테스트, DAO 테스트*

## 6.2.4 목 프레임워크

### Mockito 프레임 워크

1. 인터페이스를 이용해 목 오브젝트를 만듬
2. 목 오브젝트가 리턴할 값이나 예외를 지정
3. 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만듬
4. 오브젝트 사용 후, 목 오브젝트의 특정 메소드가 어떤 값으로 몇번 호출되었는지 검증

# 6.3 다이내믹 프록시와 팩토리 빈

## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

### 프록시

마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아줌

타깃과 같은 인터페이스를 구현하여, 프록시가 타깃을 제어할 수 있는 위치에 있음

- 클라이언트가 타깃에 접근하는 방법을 제어하기 위해
- 부가적은 기능을 부여해주기 위해

### 타깃, 실체

프록시를 통해 최종적으로 요청을 위임받아 처리하는 오브젝트

```python
클라이언트 ---> 프록시 ---> 타깃
```

### 데코레이터 패턴

타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴

실제 내용물은 동일하지만 부가적인 효과 제공

- **다이나믹하게 기능을 부여한다?**

    컴파일 시점, 즉 코드 상에서 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않음

### 프록시 패턴

프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적

타깃의 기능을 확장하거나 추가하지 않음

타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우엔 생성하지 않는 편이 좋음

하지만 레퍼런스가 미리 필요할 수 있으므로, 이때 프록시 패턴 적용

클라이언트에게 실제 타깃 오브젝트 대신 프록시를 넘겨줌

프록시의 메소드를 통해 타깃 사용시, 타깃을 생성하고 요청을 위임해줌

ex) 원격 오브젝트 이용(RMI, EJB 등), Collections의 unmodifiableCollection()

## 6.3.2 다이나믹 프록시

### 프록시를 만들기 번거로운 이유

- **타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.**

    부가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어야 함

    인터페이스의 메소드가 많아지면 유지보수가 힘듬

- **부가기능 코드가 중복될 가능성이 많다.**

    메소드가 많아지고 부가기능 적용 비율이 높아지면 유사한 코드가 중복됨
