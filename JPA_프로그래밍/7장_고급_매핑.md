# 7.1 상속 관계 매핑

관계형 데이터베이스에는 상속이라는 개념이 없다.

대신 슈퍼타입-서브타입 관계라는 모델링 기법이 가장 유사하다.

ORM에서 상속 관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것

## 7.1.1 조인 전략

엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키를 사용하는 전략

조회할 때 조인을 자주 사용함

테이블은 타입의 개념이 없기 때문에 타입을 구분하는 컬럼을 추가해야 한다.

@DiscriminatorColumn을 사용하지만 몇몇 구현체는 없이도 동작한다.

### 장점

- 테이블이 정규화된다.
- 외래 키 참조 무결성 제약조건을 활용할 수 있다.
- 저장공간을 효율적으로 사용한다.

### 단점

- 조회할 때 조인이 많이 사용되므로 성능이 저하된다.
- 조회 쿼리가 복잡하다
- 데이터를 등록할 INSERT SQL을 두 번 실행한다.

## 7.1.2 단일 테이블 전략

테이블 하나만 사용

구분 컬럼으로 어떤 자식 데이터가 저장되었는지 구분한다.

@DiscriminatorColumn을 꼭 설정해야 한다.

### 장점

- 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
- 조회 쿼리가 단순하다.

### 단점

- 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느릴 수 있음

## 7.1.3 구현 클래스마다 테이블 전략

자식 엔티티마다 테이블을 만든다. 자식 테이블 각각에 필요한 컬럼이 모두 있다.

@DiscriminatorColumn 을 사용하지 않는다.

추천하지 않는 전략

### 장점

- 서브 타입을 구분해서 처리할 때 효과적이다.
- not null 제약조건을 사용할 수 있다.

### 단점

- 여러 자식 테이블을 함께 조회할 때 성능이 느리다.
- 자식 테이블을 통합해서 쿼리하기 어렵다.

[require('develop') : 네이버 블로그](https://blog.naver.com/adamdoha/222136121899)

# 7.2 @MappedSuperClass

부모 클래스는 테이블과 매핑하지 않고 자식 클래스에게 매핑 정보만 제공할 때 사용

`**@AttributeOverride**` 부모로부터 물려받은 매핑 정보를 재정의

`**@AssociationOverride**` 연관관계 재정의

- 테이블과 매핑되지 않고 엔티티의 매핑 정보만 상속하기 위해 사용
- 엔티티가 아니므로 find나 JPQL에서 사용할 수 없다
- 추상 클래스로 만드는 것 권장

# 7.3 복합 키와 식별 관계 매핑

## 7.3.1 식별 관계 vs 비식별 관계

### 식별 관계

부모 테이블의 기본 키를 내려 받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계

### 비식별 관계

부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계

- 필수적 비식별 관계: 외래 키에 NULL 허용하지 않음
- 선택적 비식별 관계: 외래 키에 NULL 허용

## 7.3.2 복합 키: 비식별 관계 매핑

JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야 함

식별자 필드가 2개 이상이면 별도의 식별자 클래스를 만들고 equals와 hashCode를 구현해야 함

복합 키에는 @GenerateValue를 사용할 수 없다.

### @IdClass

관계형 데이터베이스에 가까운 방법

- 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자 속성명이 같아야 한다.
- Serializable 인터페이스를 구현해야 한다.
- equals, hashCode를 구현해야 한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 public 이어야 한다.

### @EmbeddedId

객체지향에 가까운 방법

특정 상황에 JPQL이 조금 더 길어질 수 있다.

- @Embeddable 어노테이션을 붙여주어야 한다.
- Serializable 인터페이스를 구현해야 한다.
- equals, hashCode를 구현해야 한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 public 이어야 한다.

### 복합 키와 equals(), hashCode()

영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다.

그리고 식별자를 비교할 때 equals()와 hashCode()를 사용하여 동등성을 비교하기 때문에 필수로 구현해야 한다.

## 7.3.6 식별, 비식별 관계의 장단점

### 데이터베이스 설계 관점에서 비식별 관계를 선호하는 이유

- 식별 관계는 자식 테이블의 기본 키 컬럼이 점점 늘어나 불필요하게 커진다.
- 식별 관계는 2개 이상의 컬럼을 합해서 복합 기본 키를 만들어야 하는 경우가 많다.
- 식별 관계를 사용할 때 기본 키로 비즈니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많다.
    
    이런 비즈니스 요구사항은 시간이 지남에 따라 언젠가 변한다.
    
- 식별 관계는 부모 테이블의 기본 키를 자식 테이블의 기본 키로 사용하므로 테이블 구조가 유연하지 못하다.

### 객체 관계 매핑 관점에서 비식별 관계를 선호하는 이유

- 일대일 관계를 제외하고 식별 관계는 2개 이상의 컬럼을 묶은 복합 기본키를 사용해야 한다.
- JPA는 비식별 관계에서 @GenerateValue와 같은 대리 키를 생성하는 편리한 방법을 제공한다.

### 식별 관계의 장점

- 기본 키 인덱스를 활용하기 좋다.
- 상위 테이블들의 기본 키 컬럼을 자식 테이블들이 가지고 있으므로 특정 상황에 조건 엇이 하위 테이블만으로 검색할 수 있다.

### 필수적 비식별 관계의 장점

선택적 비식별 관계는 NULL을 허용하므로 조인할 때 외부 조인을 사용해야 하지만,

필수적 비식별 관계는 항상 관계가 있기 때문에 내부 조인만 사용해도 된다.

# 7.4 조인 테이블

데이터 베이스 테이블의 연관관계를 설계하는 방법

### 조인 컬럼 사용(외래 키)

조인 컬럼이라 부르는 외래 키 컬럼을 사용하여 관리한다.

### 조인 테이블 사용(테이블 사용)

조인 테이블이라는 별도의 테이블을 사용해서 연관관계를 관리한다.

## 7.4.1 일대일 조인 테이블

조인 테이블의 외래 키 컬럼 각각에 총 2개의 유니크 제약조건을 걸어야 한다.

### @JoinTable

- name: 매핑할 조인 테이블 이름
- joinColumns: 현재 엔티티를 참조하는 외래 키
- inverseJoinColumns: 반대 방향 엔티티를 참조하는 외래 키

## 7.4.2 일대다 조인 테이블

다와 관련된 컬럼에 유니크 제약 조건을 걸어야 한다.

## 7.4.4 다대다 조인 테이블

조인 테이블의 두 컬럼을 합해서 하나의 복합 유니크 제약조건을 걸어야 한다.

# 7.5 엔티티 하나에 여러 테이블 매핑

@SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있다.

이 방법보단 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장한다.

→ 항상 두 테이블을 조회하므로 최적화가 어려움
