# 10.1 객체지향 쿼리 소개

테이블이 아닌 엔티티 객체를 대상으로 검색하기 위해 JPQL이 만들어짐

- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.

## 10.1.2 Criteria 쿼리 소개

문자가 아닌 코드로 JPQL을 작성

- 컴파일 시점에 오류를 발견할 수 있다.
- IDE를 사용하면 코드 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편하다.
- 복잡하고 한눈에 들어오지 않는다.

## 10.1.3 QueryDSL 소개

Criteria와 같은 JPQL 빌더 역할

Criteria에 비해 단순하고 사용하기 쉽다.

## 10.1.4 네이티브 SQL 소개

JPA에서 SQL을 직접 사용하는 기능

특정 데이터베이스에 의존하는 기능을 사용해야 할 때나 JPQL이 지원하지 않는 기능을 사용할 때

## 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용

JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 함

이러한 방식은 JPA를 우회해서 데이터베이스에 접근하기 때문에 JPA가 전혀 인식하지 못한다.

따라서 JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터베이스와 영속성 컨텍스트를 동기화해야 함

스프링 프레임워크를 사용하면 손쉽게 통합할 수 있다.

# 10.2 JPQL

- 객체지향 쿼리 언어. 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- 실행 시 SQL로 변환된다.

## 10.2.1 기본 문법과 쿼리 API

SELECT, UPDATE, DELETE 문을 사용할 수 있다.

엔티티를 저장할 땐 persist 메소드를 사용하면 되므로 INSERT 문은 없다.

### SELECT 문

- 대소문자 구분
    
    엔티티와 속성은 대소문자를 구분하고, JPQL 키워드는 구분하지 않는다.
    
- 엔티티 이름
    
    JPQL에서 사용한 테이블 명은 클래스 명이 아니라 엔티티 명이다.
    
- 별칭은 필수

### TypeQuery, Query

반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 사용

반환할 타입을 명확하게 지정할 수 없으면 Query 객체 사용, Object 반환

## 10.2.2 파라미터 바인딩

JDBC는 위치 기준 파라미터 바인딩만 지원하지만, JPQL은 이름 기준 파라미터 바인딩도 지원

## 10.2.3 프로젝션

SELECT 절에 조회할 대상을 지정하는 것

### 엔티티 프로젝션

원하는 객체 조회

조회한 엔티티는 영속성 컨텍스트에서 관리됨

### 임베디드 타입 프로젝션

임베디드 타입은 조회의 시작점이 될 수 없다.

엔티티를 통해서 조회 가능

임베디드 타입은 값 타입이기 때문에 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않음

### 스칼라 타입 프로젝션

숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라고 함

### NEW 명령어

SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정할 수 있음

- 패키지 명을 포함한 전체 클래스 명을 입력해야 함
- 순서와 타입이 일치하는 생성자가 필요

## 10.2.4 페이징 API

데이터베이스마다 페이징을 처리하는 문법이 다르기 때문에 API로 추상화했다.

- setFirstResult: 조회 시작 위치
- setMaxResults: 조회할 데이터 수

## 10.2.5 집합과 정렬

### 집합 함수

COUNT, MAX, MIN, AVG, SUM

### 집합 함수 사용 시 참고사항

- NULL 값은 무시하므로 통계에 잡히지 않는다.
- 값이 없으면 NULL이 된다(COUNT는 0)
- DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.
- DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다.

## 10.2.6 조인

JPQL조인은 연관 필드를 사용한다.

- 연관필드: 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드

- 명시적 조인: JOIN을 직접 적어줌
- 묵시적 조인: 경로 표현식에 의해 묵시적으로 조인이 일어나는 것, INNER JOIN

### 내부 조인

INNER JOIN 사용, INNER 생략 가능

### 외부 조인

OUTER를 생략해 LEFT JOIN으로 사용

### 컬렉션 조인

일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것

### 세타 조인

전혀 관계없는 엔티티 조인

WHERE 절을 사용하며 내부조인만 가능

### JOIN ON 절

조인 대상을 필터링하고 조인할 수 있음

내부 조인의 ON은 WHERE 절과 같으므로 보통 외부조인에서 사용

## 10.2.7 페치 조인

JPQL의 성능 최적화를 위해 제공하는 기능

연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능

### 엔티티 페치 조인

페치 조인은 별칭을 사용할 수 없다.

### 컬렉션 페치 조인

연관된 테이블도 함께 조회하기 때문에 결과가 증가한다.

일대다 조인은 결과가 증가할 수 있지만 일대일, 다대일 조인은 결과가 증가하지 않는다.

### 페치 조인과 DISTINCT

JPQL의 DISTINCT 명령어는 SQL에 DISTINCT를 추가하는 것은 물론이고 어플리케이션에서 한번 더 중복을 제거한다.

### 페치 조인과 일반 조인의 차이

JPQL은 결과를 반환할 때 연관관계까지 고려하지 않는다. SELECT 절에 지정한 엔티티만 조회

따라서 연관된 엔티티의 경우 지연로딩일 경우 프록시나 컬렉션 래퍼를 반환하고

즉시 로딩일 경우 쿼리를 한번 더 실행한다.

반면 페치 조인은 연관된 엔티티도 함께 조회

### 페치 조인의 특징과 한계

**특징**

페치 조인을 사용하면 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어 SQL 호출 횟수를 줄여 **성능을 최적화**할 수 있음

글로벌 로딩 전략보다 페치 조인을 우선하기 때문에 지연 로딩으로 설정해도 함께 조회

- 글로벌 로딩 전략: 엔티티에 직접 적용하는 로딩 전략은 어플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라고 함 ex) 지연로딩, 즉시로딩

페치 조인을 사용하면 연관된 엔티티를 쿼리 시점에 조회하므로 지연로딩이 발생하지 않아 준영속 상태에서도 **객체 그래프를 탐색**

**한계**

- 페치 조인 대상에는 별칭을 줄 수 없음
    - SELECT, WHERE 절, 서브쿼리에 페치 조인 대상을 사용할 수 없다.
- 둘 이상의 컬렉션을 페치할 수 없음
- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없음
    - 일대다가 아닌 단일 값 연관 필드(일대일, 다대일)은 페치 조인으로도 페이징 API 사용 가능
    - 하이버네이트에서 컬렉션을 패치 조인할 때 메모리에서 페이징 처리하기 때문에 성능 이슈와 메모리 초과 예외가 발생할 수 있음

## 10.2.8 경로 표현식

.을 찍어 그래프를 탐색하는 것

### 경로 표현식의 용어 정리

- 상태 필드: 단순히 값을 저장하기 위한 필드
- 연관 필드: 연관관계를 나타내기 위한 필드, 임베디드 타입 포함
    - 단일 값 연관 필드: @ManyToOne, @OneToOne, 대상이 엔티티
    - 컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션

### 경로 표현식과 특징

- 상태 필드 경로: 경로 탐색의 끝. 더는 탐색할 수 없음
- 단일 값 연관 경로: 묵시적 내부 조인, 단일 값 연관 경로는 계속 탐색 가능
- 컬렉션 값 연관 경로: 묵시적으로 내부 조인. 더는 탐색할 수 없음. 별칭을 얻으면 별칭으로 탐색

### 경로 탐색을 사용한 묵시적 조인 시 주의사항

- 항상 내부 조인이다.
- 컬렉션은 경로 탐색의 끝. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인해야 함
- 경로 탐색은 주로 SELECT, WHERE에서 사용하지만 묵시적 조인으로 인해 FROM절에 영향을 줌

성능이 중요하면 분석하기 쉽도록 명시적 조인을 사용하자

## 10.2.9 서브 쿼리

WHERE, HAVING 절에만 사용

SELECT, FROM 절에서는 사용할 수 없음

## 10.2.11 다형성 쿼리

JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회

### TYPE

엔티티의 상속 구조에서 조희 대상을 특정 자식 타입으로 한정할 때 사용

### TREAT

자바의 타입 캐스팅과 같은 역할

부모 타입을 특정 자식 타입으로 다룰 때 사용
