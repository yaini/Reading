# 15.1 예외 처리

## 15.1.1 JPA 표준 예외 정리

### JPA 표준 예외

- 트랜잭션 롤백을 표시하는 예외
- 트랜잭션 롤백을 표시하지 않는 예외

## 15.1.2 스프링 프레임워크의 JPA 예외 변환

서비스 계층에서 데이터 접근 계층의 구현 기술에 직접 의존하는 것은 좋은 설계라 할 수 없다

서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 된다

스프링 프레임워크는 이런 문제를 해결하려고 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공

## 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용

PersistenceExceptionTranslationPostProcessor를 스프링 빈으로 등록

@Repository 어노테이션을 사용한 곳에 예외 변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해 줌

## 15.1.4 트랜잭션 롤백 시 주의사항

트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지 않는다.

따라서 롤백된 영속성 컨텍스트를 그대로 사용하는 것은 위험하다.

스프링 프레임워크는 이런 문제를 예방하기 위해 영속성 컨텍스트의 범위에 따라 다른 방법 사용

기본 전략은 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않음

OSIV는 하나의 영속성 컨텍스트를 여러 트랜잭션이 사용하기 때문에 문제가 발생하는데, 트랜잭션 롤백시 영속성 컨텍스트를 초기화 한다.

# 15.2 엔티티 비교

1차 캐시는 영속성 컨텍스트와 생명주기를 같이한다.

### 어플리케이션 수준의 반복 가능한 읽기

같은 영속성 컨텍스트에서 엔티티를 조회하면 항상 주소 값이 같은 인스턴스 반환

## 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교

영속성 컨텍스트가 같으면 엔티티를 비교할 때 다음 조건을 모두 만족

- 동일성: ==
- 동등성: equals
- 데이터베이스 동등성: 식별자 같음

## 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교

- 동일성: == 비교 실패
- 동등성: 만족
- 데이터베이스 동등성: 만족

# 15.3 프록시 심화 주제

## 15.3.1 영속성 컨텍스트와 프록시

### 프록시 조회 → 원본 엔티티 조회

프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾는 요청이 오면 원본 엔티티가 아닌 처음 조회된 프록시 반환

따라서 프록시로 조회해도 영속 엔티티의 동일성을 보장

### 원본 엔티티 조회 → 프록시 조회

프록시가 아닌 원본 반환

영속성 엔티티의 동일성 보장

## 15.4.2 프록시 타입 비교

프록시로 조회한 엔티티의 타입을 비교할 땐 ==이 아니라 instanceOf를 사용해야 함

## 15.3.3 프록시 동등성 비교

equals 메소드를 오버라이딩 할 때 타입은 instanceOf로, 멤버 필드는 접근자 메소드로 비교해야 한다.

## 15.3.4 상속 관계와 프록시

프록시를 부모 타입으로 조회하면 부모 타입을 기반으로 프록시 생성

- instanceOf 연산 사용 불가능
- 하위 타입으로 다운 캐스팅 불가능

### JPQL로 대상 직접 조회

처음부터 자식 타입을 직접 조회

### 프록시 벗기기

하이버네이트의 unProxy를 사용하면 원본 엔티티를 가져올 수 있다.

영속성 컨텍스트는 한번 프록시로 노출한 엔티티는 계속 프록시로 노출하기 때문에 동일성 비교 문제가 있다.

따라서 이 방법은 원본 엔티티가 필요한 곳에 잠깐 사용하고 다른 곳에서 사용하지 않도록 주의해야 함

### 기능을 위한 별도의 인터페이스 제공

공통 인터페이스를 만들어 자식 클래스에서 구현

### 비지터 패턴 사용

**장점**

- 프록시에 대한 걱정 없이 안전하게 원본 엔티티 접근
- instanceOf와 타입캐스팅 없이 코드 구현
- 알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작 추가

**단점**

- 너무 복잡하고 더블 디스패치를 사용하기 때문에 이해하기 어려운
- 객체 구조가 변경되면 모든 Visitor를 수정해야 함

# 15.4 성능 최적화

## 15.4.1 N+1 문제

### 즉시 로딩과 N+1

JPQL로 select를 실행하면 로딩을 신경쓰지 않고 SQL을 생성한다.

따라서 해당 엔티티를 먼저 로딩한 다음에 연관된 엔티티를 로딩한다.

### 지연 로딩과 N+1

연관된 엔티티를 조회할 때 발생

### 패치 조인 사용

N+1 문제를 해결하는 가장 일반적인 방법

### 하이버네이트 @BatchSize

연관된 엔티티를 조회할 때 지정한 size만큼 sql의 in 절을 사용하여 조회

size 이상 데이터를 요청하면 sql을 추가로 실행

### 하이버네이트 @Fetch(FetchMode.SUBSELECT)

연관된 엔티티를 조회할 때 서브 쿼리를 사용해서 N+1 문제 해결

## 15.4.2 읽기 전용 쿼리의 성능 최적화

엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경 감지까지 얻을 수 있는 기능들이 많다.

하지만 스냅샷 인스턴스를 보관해야 하므로 더 많은 메모리를 사용하는 단점이 있다.

한 번만 읽어서 화면에 출력하는 엔티티는 읽기 전용으로 조회하면 메모리 사용량을 최적화 할 수 있다.

### 스칼라 타입으로 조회

영속성 컨텍스트가 결과를 관리하지 않음

### 읽기 전용 쿼리 힌트 사용

읽기 전용이므로 영속성 컨텍스트에서 스냅샷을 보관하지 않는다.

### 읽기 전용 트랜잭션 사용

스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있음

강제로 플러시 호출을 하지 않는 한 플러시가 일어나지 않는다.

### 트랜잭션 밖에서 읽기

트랜잭션 없이 엔티티를 조회

플러시가 일어나지 않으므로 조회 성능이 향상

## 15.4.3 배치 처리

수백만건의 엔티티를 계속 조회하면 아주 많은 엔티티가 쌓이면서 메모리 부족 오류가 발생한다.

이런 배치 처리는 적절한 단위로 영속성 컨텍스트를 초기화해야 한다.

또한 2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야 한다.

### JPA 등록 배치

수만 건 이상의 엔티티를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록 일정 단위마다 데이터 베이스에 플러시하고 초기화해야 한다.

**수정 배치 처리 방법**

- 페이징 처리: 데이터 베이스 페이징 기능 사용
- 커서: 데이터 베이스가 지원하는 커서 기능 사용

### JPA 페이징 배치 처리

페이지 단위마다 엔티티를 조회, 수정하고 영속성 컨텍스트를 플러시, 초기화 함

### 하이버네이트 scroll 사용

JPA는 JDBC 커서를 지원하지 않기 때문에 하이버네이트 세션을 사용해야 함.

하이버네이트는 scroll이라는 이름으로 JDBC 커서 지원

엔티티를 하나씩 조회

### 하이버네이트 무상태 세션 사용

영속성 컨텍스트를 만들지 않고 2차 캐시도 사용하지 않는다.

엔티티를 수정하려면 update 메소드 호출

## 15.4.4 SQL 쿼리 힌트 사용

SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 함

## 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화

### 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치

네트워크 호출은 메소드를 수만 번 호출하는 것보다 더 큰 비용이 들기 때문에 sql을 모아서 한 번에 데이터베이스에 보낸다

IDENTITY 식별자 전략은 persist를 호출하는 즉시 데이터베이스에서 식별자를 가져와야 하기 때문에 쓰기 지연을 활용한 성능 최적화를 할 수 없다.

### 트랜잭션을 지원하는 쓰기 지연과 어플리케이션 확장성

트랜잭션은 데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화 한다.

트랜잭션은 영속성 컨텍스트를 플러시하기 전까지 데이터베이스를 등록, 수정, 삭제하지 않기 때문에 락을 걸지 않는다.
