# 14.1 컬렉션

### 컬렉션을 사용하는 경우

- @OneToMany, @ManyToMany를 사용하여 엔티티 매핑
- @ElementCollection을 사용해서 값 타입을 하나 이상 보관

## 14.1.1 JPA와 컬렉션

하이버네이트는 엔티티를 영속 상태로 만들 때 컬렉션 필드를 하이버네이트에서 준비한 컬렉션으로 감싸서 사용

래퍼 컬렉션이라고도 함

## 14.1.2 Collection, List

PersistentBag을 래퍼 컬렉션으로 사용

중복 허용, 순서 없음

엔티티를 추가해도 지연 로딩된 컬렉션을 초기화하지 않음

## 14.1.3 Set

PersistentSet을 래퍼 컬렉션으로 사용

중복 허용하지 않음, 순서 없음

엔티티를 추가할 때 지연 로딩된 컬렉션을 초기화

## 14.1.4 List+@OrderColumn

순서가 있는 특수한 컬렉션으로 인식

데이터베이스에 순서 값을 저장해서 조회할 때 사용

실무에선 잘 사용하지 않는다.

### 단점

- update하는 sql 추가로 발생
- 값 변경시 연관된 값들 추가로 변경
- 중간에 값이 없으면 null로 보관됨

## 14.1.5 @OrderBy

order by절을 사용해서 컬렉션 관리

모든 컬렉션에 사용 가능

# 14.2 @Converter

엔티티의 데이터를 변환해서 데이터베이스에 저장

autoApply를 통해 글로벌하게 적용 가능

# 14.3 리스너

엔티티의 생명주기에 따른 이벤트 처리

## 14.3.1 이벤트 종류

- PostLoad: 영속성 컨텍스트에 조회된 직후 또는 refresh를 호출한 후
- PrePersist: persist 메소드를 호출해서 엔티티를 영속성 컨텍스트에 관리 직전에 호출 혹은 새로운 인스턴스 merge
- PreUpdate: flush나 commit을 호출해서 엔티티를 데이터베이스에 수정하기 직전
- PreRemove: remove 메소드를 호출해서 엔티티를 영속성 컨텍스트에 삭제하기 직전
- PostPersist: flush나 commit을 호출해서 엔티티를 데이터베이스에 저장한 직후
- PostUpdate: flush나 commit을 호출해서 엔티티를 데이터베이스에 수정한 직후
- PostRemove: flush나 commit을 호출해서 엔티티를 데이터베이스에 삭제한 직후

## 14.3.2 이벤트 적용 위치

- 엔티티에 직접 적용
- 별도의 리스너 등록
- 기본 리스너 사용

# 14.4 엔티티 그래프

엔티티를 조회하는 시점에 함께 조회할 연관된 엔티티 선택

## 14.4.1 Named 엔티티 그래프

### @NamedEntityGraph

- name: 엔티티 그래프의 이름을 정의한다.
- attributeNode: 함께 조회할 속성 선택

## 14.4.2 em.find()에서 엔티티 그래프 사용

JPA의 힌트 기능을 사용해서 동작

## 14.4.3 subgraph

연관된 엔티티의 연관된 엔티티 조회

## 14.4.4 JPQL에서 엔티티 그래프 사용

힌트 추가

## 14.4.5 동적 엔티티 그래프

createEntityGraph 사용

## 14.4.6 엔티티 그래프 정리

### Root에서 시작

항상 조회하는 엔티티의 root에서 시작해야 함

### 이미 로딩된 엔티티

영속성 컨텍스트에 해당 엔티티가 이미 로딩되어 있으면 엔티티 그래프가 적용되지 않는다.

### fetchgraph, loadgraph 차이

fetchgraph는 엔티티 그래프에 선택한 속성만 함께 조회

loadgraph는 글로벌 fetch모드가 eager로 설정된 연관관계도 포함하여 함께 조회
