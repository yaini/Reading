# 13.1.1 스프링 컨테이너의 기본 전략

스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용

트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다.

같은 트랙잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

@Transactional 어노테이션을 선언하면 메소드 실행 직전에 스프링의 트랜잭션 AOP 동작

### 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.

엔티티 매니저가 달라도 트랜잭션이 같으면 같은 영속성 컨텍스트 사용

같은 엔티티 매니저를 사용해도 트랜잭션이 다르면 다른 영속성 컨텍스트 사용

스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당하여 영속성 컨텍스트가 다르므로 멀티스레드 상황에 안전

# 13.2 준영속 상태와 지연 로딩

조회한 엔티티는 서비스와 레포지토리 계층에선 영속 상태를 유지하지만

컨트롤러나 뷰 같은 프레젠테이션 계층에서는 준영속 상태가 됨

준영속 상태에선 변경 감지와 지연 로딩이 발생하지 않음. 예외 발생

### 준영속 상태와 변경 감지

변경 감지 기능은 영속성 컨텍스트가 살아있는 서비스 계층(트랜잭션 범위)까지만 동작

변경 감지 기능은 보통 서비스 계층에서 비즈니스 로직을 수행하면서 발생

**프레젠테이션 계층에 변경 감지 기능이 없는 이유**

- 어플리케이션 계층이 가지는 책임이 모호
- 데이터 변경을 프레젠테이션 계층까지 찾아야 하므로 유지보수 어려움

### 준영속 상태와 지연 로딩

**해결하는 방법**

- 뷰가 필요한 엔티티를 미리 로딩
    - 글로벌 패치 전략 수정
    - JPQL 패치 조인
    - 강제로 초기화
- OSIV를 사용해서 엔티티를 항상 영속 상태로 유지

## 13.2.1 글로벌 패치 전략 수정

지연로딩에서 즉시로딩으로 변경

### 단점

- 사용하지 않는 엔티티 로딩
- N+1문제 발생
    - 해결방법: JPQL 패치 조인 사용

JPA가 JPQL을 분석해서 SQL을 생성할 때는 글로벌 패치 전략을 참고하지 않고 오직 JPQL자체만 사용

## 13.2.2 JPQL 패치 조인

N+1 문제를 해결하면서 엔티티를 미리 로딩하는 현실적인 방법

### 단점

무분별하게 사용하면 프레젠테이션 계층에 맞춘 레포지토리 메소드가 증가할 수 있음

## 13.2.3 강제로 초기화

영속성 컨텍스트가 살아있을 때 프레젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환

## 13.2.4 FACADE 계층 추가

비즈니스 로직을 담당하는 서비스 계층과 프레젠테이션 계층을 위한 프록시 초기화를 분리하기 위해 추가

# 13.3 OSIV

영속성 컨텍스트를 뷰까지 열어둔다는 뜻

## 13.3.1 과거 OSIV: 요청 당 트랜잭션

클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션도 끝냄

### 문제점

컨트롤러나 프레젠테이션 계층이 엔티티를 변경

### 해결방안

- 엔티티를 읽기 전용 인터페이스로 제공
- 엔티티 래핑
- DTO만 반환

## 13.2.2 스프링 OSIV: 비즈니스 계층 트랜잭션

### 스프링 OSIV 분석

영속성 컨텍스트는 프레젠테이션 계층까지 사용하지만 트랜잭션은 비즈니스 계층에서만 사용

### 트랜잭션 없이 읽기

영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회할 수 있다.

### 주의사항

엔티티를 수정한 직후에 트랜잭션을 시작하는 서비스 계층 호출 시 문제 발생

- 비즈니스 로직을 실행하고 엔티티를 수정하자
- 여러 트랜잭션이 영속성 컨텍스트를 공유하여 발생

### 단점

- 복잡한 데이터는 엔티티로 조회하기 보다 DTO로 조회하는 것이 효과적
- JVM을 벗어난 상황에선 사용할 수 없음
