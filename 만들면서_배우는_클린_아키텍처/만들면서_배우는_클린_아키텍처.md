# 01 계층형 아키텍처의 문제는 무엇일까?

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다.

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 때문에 데이터베이스에 의존하게 된다.

이 때, 상태가 아닌 행동을 중심으로 모델링 하게 되고, 행동이 비즈니스를 이끌어간다.

이렇게 되면 영속성 계층과 도메인 계층의 강한 결합이 생기고, 영속성 모델을 비즈니스 모델처럼 사용하게 된다.

## 지름길을 택하기 쉬워진다.

계층형 아키텍처에서 전체적으로 적용되는 규칙은, 같은 계층의 컴포넌트나 아래 계층에만 접근 가능하다는 것이다.

이로 인해 영속성 계층이 각종 헬퍼와 유틸리티로 인해 비대해질 가능성이 크다.

## 테스트하기 어려워 진다

엔티티 필드를 조작하여 데이터를 저장하는 코드가 생기기 시작하면

도메인 로직이 웹 계층에 들어가게 되거나 웹 계층 테스트에서 영속성 계층도 모킹해야되는 경우가 생기게 된다.

## 유스케이스를 숨긴다

여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.

이렇게 되면 서비스를 테스트하기도 어려워지고, 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

## 동시 작업이 어려워 진다

특정 기능에 대해 동시에 한 명의 개발자만 작업할 수 있게 된다.

# 02 의존성 역전하기

## 단일 책임 원칙

컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.

많은 컴포넌트가 서로 의존성을 가지게 되면, 시간이 갈수록 변경하기 어려워진다.

## 부수효과에 관한 이야기

코드가 실제로 어떤 일을 하는지 이해하기 쉽지 않았고, 다른 영역에서 부수효과가 생겨나게 되었다.

## 의존성 역전 원칙

코드 상의 어떤 의존성이든 그 방향을 역전시킬수 있다.

엔티티의 상태를 변경하기 위해 엔티티를 도메인 계층으로 올리게 되면, 두 계층 사이에 순환 의존성이 생기게 된다.

## 클린 아키텍처

클린 아키텍처는 설계가 비즈니스 규칙 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크/데이터베이스/UI 기술/그 밖의 외부 어플리케이션이나 인터페이스로부터 독립적일 수 있다.

이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다. 대신 의존성 역전 원칙으로 모든 의존성이 도메인 코드를 향하고 있다.

## 육각형 아키텍처

어플리케이션 코어가 육각형으로 표현되어 아키텍처의 이름이 되었다. 다른 시스템이나 어댑터와 연결되는 4개 이상의 면을 가질 수 있음을 보여주기 위해 육각형을 사용했다고 한다.


# 04 유스케이스 구현하기

## 풍부한 도메인 모델 vs 빈약한 도메인 모델

### 풍부한 도메인 모델

엔티티의 역할

- 가능한 많은 도메인 로직 구현
- 상태를 변경하는 메서드 제공
- 비즈니스 규칙에 맞는 유효한 변경

유즈케이스의 역할

- 사용자의 의도만을 표현
- 실제 작업을 수행하는 엔티티의 메서드 호출

### 빈약한 도메인 모델

엔티티의 역할

- 상태를 표현하기 위한 필드
- getter, setter 메소드만 포함

유즈케이스의 역할

- 도메인 로직 구현
- 비즈니스 규칙 검증
- 엔티티 상태 변경
- outgoing port로 엔티티 전달

## 유즈케이스마다 다른 출력 모델

출력은 호출자에게 꼭 필요한 데이터만 들고 있어야 한다.

유즈케이스들 간에 같은 출력 모델을 공유하게 되면 유즈케이스들이 강하게 결합된다.

단일 책임 원칙을 적용하고 모델을 분리해서 유지하는 것이 결합을 제거하는데 도움이 된다.

또한 도메인 엔티티를 출력 모델로 사용해서는 안된다.

## 읽기 전용 유스케이스는 어떨까?

쿼리를 위한 인커밍 전용 포트를 만들고 **쿼리 서비스**에 구현

읽기 전용 쿼리는 쓰기 유스케이스와 코드상에서 명확하게 구분된다.

CQS(Command-Query Separation)이나 CQRS(Command-Query Reponsibility Segregation) 같은 개념과 잘맞는다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

### 장점

도메인 로직을 우리가 원하는대로 구현 가능

입출력 모델을 독립적으로 매핑한다면 부수효과를 피할 수 있음

유스케이스 별로 모델을 만들면 유스케이스를 명확하게 이해할 수 있고 유지보수가 쉽다.

다른 사람이 작업중인 유스케이스를 건들이지 않은 채로 여러 개의 유스케이스를 동시에 작업할 수 잇따.

### 단점

유스케이스 간에 모델을 공유하는 것보다 더 많은 작업

별도의 모델을 만들어야 하고 모델과 엔티티를 매핑해야 한다.

# 05 웹 어댑터 구현하기

## 의존성 역전

### 웹 어댑터

‘주도하는’ 혹은 ‘인커밍' 어댑터

외부로부터 요청을 받아 어플리케이션 코어를 호출하고 무슨 일을 해야 할지 알려준다.

제어 흐름은 웹 어댑터에 있는 컨트롤러에서 어플리케이션 계층에 있는 서비스로 흐른다.

한 어댑터가 인커밍 어댑터와 아웃커밍 어댑터를 동시에 할 수 있다.

```bash
컨트롤러(adapter.in.web) -> 포트-interface(applicaiton.port.in) -> 서비스(application.service)
```

### 어댑터와 유스케이스 사이에 간접 계층을 넣어야 하는 이유

어플리케이션 코어가 외부 세계와 통신할 수 있는 곳에 대한 명세가 포트이다.

포트를 적절한 곳에 위치시키면 외부와 어떤 통신이 일어나는지 알 수 있다.

## 웹 어댑터의 책임

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환

### 입력 유효성 검증

웹 어댑터의 입력 모델과 유스케이스의 입력 모델은 구조와 의미가 다를 수 있으므로 다른 유효성 검증을 해야 한다.

웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.

### 책임

HTTP와 관련된 것은 어플리케이션 계층으로 침투해서는 안된다.

어플리케이션 코어가 HTTP에 대한 정보를 알게되면, HTTP를 사용하지 않는 또 다른 인커밍 어댑터의 요청에 대해 동일한 도메인 로직을 수행할 수 있응 선택지를 잃게 된다.

## 컨트롤러 나누기

컨트롤러는 다른 컨트롤러와 가능한 적게 공유하는 웹 어댑터 조각을 구현해야 한다.

클래스가 작을수록 원하는 코드를 찾기 쉽고, 데이터 구조의 재활용을 촉진한다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

웹 어댑터의 역할은 HTTP 요청을 어플리케이션의 유스케이스에 대한 메소드 호출로 변환/결과 값을 다시 HTTP로 변환만을 가지고 있어야 한다.

반면 어플리케이션 계층은 HTTP에 대한 작업을 하면 안된다. 이렇게 되면 필요한 경우 웹 어댑터가 아닌 다른 어댑터로 쉽게 교체할 수 있다.

# 06 영속성 어댑터 구현하기

## 의존성 역전

영속성 어댑터는 ‘주도되는’ 혹은 ‘아웃고잉' 어댑터이다.

어플리케이션에 의해 호출될 뿐, 어플리케이션을 호출하지 않는다.

자연스럽게 의존성은 어플리케이션 코어에서 영속성 어댑터로 향한다.

이렇게 코어에 영향을 미치지 않으며 영속성 코드를 마음껏 수정할 수 있다.

## 영속성 어댑터의 책임

1. 입력을 받는다
2. 입력을 데이터베이스 포맷으로 매핑한다
3. 입력을 데이터베이스로 보낸다
4. 데이터베이스 출력을 어플리케이션 포맷으로 매핑한다
5. 출력을 반환한다

## 인터페이스 분리 원칙

클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리해야 한다.

이러한 원칙을 적용한 포트는 plug-and-play 경험을 만든다.

## 영속성 어댑터 나누기

각 영속성 기능을 이용하는 도메인 경계를 따라 나눈다.

## 데이터베이스 트랜잭션

하나의 측정한 유스케이스에서 일어나는 모든 쓰기 작업에 걸쳐 있어야 실패할 경우 다 같이 롤백될 수 있다.

AOP를 통해 트랜잭션 경계를 코드에 위빙(weaving) 할 수 있다.

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?

도메인 코드와 영속성 코드와 분리되어 풍부한 도메인 모델을 만들 수 있다.

좁은 포트 인터페이스를 사용하면 포트마다 다른 방식으로 구현할 수 있는 유연함이 생긴다.

# 07 아키텍처 요소 테스트하기

## 테스트 피라미드

```bash
시스템 테스트 < 통합 테스트 < 단위 테스트
```

### 단위 테스트

하나의 클래스를 인스턴스화 하고 클래스의 인터페이스를 통해 기능들을 테스트 한다.

의존하는 클래스들은 mock으로 대체한다.

### 통합 테스트

여러 유닛을 인스턴스화하고 유닛들의 네트워크가 기대한대로 잘 동작하는지 검증한다.

### 시스템 테스트

어플리케이션을 구성하는 모든 객체 네트워크를 가동시켜 특정 유스케이스가 전 계층에서 잘 동작하는지 검증한다.

JGiven 같은 라이브러리를 통해 행동 주도 테스트를 실행할 수 있다.

## 테스트

모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 한다.

이는 테스트의 가치를 떨어뜨리며 중요한 핵심만 골라 집중해서 테스트하는 것이 좋다.

## 얼마만큼의 테스트가 충분할까?

### 육각형 아키텍처에서 사용하는 전략

- 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
- 유스케이스를 구현할 때는 단위 테스트로 커버하자
- 어댑터를 구현할 때는 통합테스트로 커버하자
- 사용자가 취할 수 있는 중요 어플리케이션 경로는 시스템 테스트로 커버하자

# 08 경계 간 매핑하기

## 매핑

### 장점

계층이 강하게 결합되는 것을 막아준다

### 단점

보일러 플레이트 코드를 많이 만들게 된다

## 전략

### No Mapping 전략

하나의 모델에서 웹, 영속성, 비즈니스 요구사항을 모두 다루어야 한다.

이는 단일 책임 원칙을 위반하게 된다.

하지만 모든 계층이 정확히 같은 구조와 정보를 필요로 하는 간단한 CRUD 유스케이스엔 유용하다.

### Two-Way Mapping 전략

각 계층이 전용 모델을 가진 매핑 전략

단일 책임 원칙을 만족하며 매핑 책임이 명확하다.

하지만 너무 많은 보일러플레이트 코드가 생기며 도메인 모델이 계층 경계를 넘기 때문에 바깥쪽 계층의 요구에 따른 변경에 취약해 진다.

### Full Mapping 전략

각 연산마다 별도의 입출력 모델을 사용한다.

Commnad, Request와 같은 각 작업에 특화된 모델을 사용한다.

각 유스케이스는 전용 필드와 유효성 검증 로직을 가진 전용 커맨드를 가진다.

구현하고 유지보수하기 쉬워진다.

### One-Way Mapping 전략

모든 계층의 모델들이 같은 인터페이스를 구현한다.

인터페이스는 관련 있는 특성에 대한 getter 메소드를 제공해서 도메인 모델의 상태를 캡슐화 한다.

상태 인터페이스로 인해 도메인 객체를 바깥 계층으로 전달하고 싶으면 매핑 없이 할 수 있다.

DDD 개념의 팩토리와 잘 어울린다.

계층 간의 모델이 비슷할 때 가장 효과적이다.

- 팩토리: 어떤 특정한 상태로부터 도메인 객체를 재구성할 책임을 가지고 있다.

## 언제 어떤 매핑 전략을 사용할 것인가?

### 변경 유스케이스 - 웹 계층과 어플리케이션 계층

결합 제거를 위해 완전 매핑 전략

유효성 검증 규칙이 명확해짐

### 변경 유스케이스 - 어플리케이션 계층과 영속성 계층

매핑 오버헤드를 줄이기 위해 매핑하지 않기 전략

어플리케이션에서 영속성 문제를 다루어야 하게 되면 양방향 매핑 전략으로 바꾸자

### 쿼리 작업 - 웹 계층과 어플리케이션 계층, 어플리케이션 계층과 영속성 계층

매핑하지 않기 전략

어플리케이션에서 웹 문제나 영속성 문제를 다루어야 하게 되면 양방향 매핑 전략으로 바꾸어야 한다.

# 09 어플리케이션 조립하기

## 왜 조립까지 신경 써야 할까?

코드 의존성이 올바른 방향을 가리키게 하기 위해서

모든 의존성은 안쪽으로, 어플리케이션의 도메인 코드 방향으로 향해야 도메인 코드가 바깥 계층의 변경으로부터 안전하다.

아키텍처에 대해 중립적이고 인스턴스 생성을 위해, 모든 클래스에 대한 의존성을 가지는 **설정 컴포넌트**가 있어야 한다.

단일 책임원칙을 위반한다. 그러나 어플리케이션의 설정 컴포넌트 외의 책임분리를 깔끔하게 유지하고 싶다면 필요하다.

### 조립 방법

- 코드로 조립
- 스프링의 classpath scanning으로 조립
- java config로 조립

# 10 아키텍처 경계 강제하기

## 경계와 의존성

계층 경계를 넘는 의존성은 항상 안쪽 방향으로 향해야 한다.

## 접근 제한자

### package-private

모듈 내의 클래스들은 서로 접근 가능하지만 패키지 바깥에서는 접근할 수 없다.

진입점으로 활용될 클래스들만 골라서 public으로 만들면 된다.

## 컴파일 후 체크

코드가 컴파일 된 후 런타임에 체크

ArchUnit 도구를 활용하는 방법이 있다.

하드 코딩이기 때문에 유지보수에 취약하다.

## 빌드 아티팩트

자동화된 빌드 프로세스의 결과물

계층의 전용 코드 베이스와 빌드 아티팩트로 분리된 빌드 모듈을 만듬

각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정

# 11 의식적으로 지름길 사용하기

## 깨진 창문 이론

한번 어지럽혀진 질서는 계속해서 어지럽혀지기 쉽다.

### 유즈 케이스간 모델 공유하기

모델을 공유한다는 것은 특정 세부사항을 변경할 경우 두 유즈케이스 모두에 영향을 주고 싶다는 것을 뜻한다.

### 도메인 엔티티를 입출력 모델로 사용하기

도메인 엔티티에 존재하지 않는 정보를 유스케이스가 필요로 한다면, 도메인 엔티티에 필요 없는 필드가 추가적으로 생기게 된다.

고로 전용 입출력 모델이 필요하게 된다.

### 인커밍 포트 건너뛰기

아웃고잉 포트는 의존성을 역전시키기 위한(의존성이 안쪽으로 향하게 하는) 필수 요소인 반면

인커밍 포트는 의존성 역전에 필수적인 요소는 아니다.

하지만 인커밍 포트가 없다면 어댑터에서 어플리케이션 내부 동작에 대해 더 잘 알아야 한다.

또한 인커밍 포트가 있다면 아키텍처를 강제할 수 있고, 서비스 메소드를 실수로 호출하는 일이 발생하지 않는다.

### 어플리케이션 서비스 건너뛰기

이 경우는 인커밍 어댑터와 아웃고잉 어댑터 사이에 모델을 공유해야 한다.

또한 유스케이스가 없어져 도메인 로직이 아웃고잉 어댑터에 추가될 가능성이 있다.
